#pragma once

#include <string>
#include <unordered_map>

#include "glad/gl.h"

namespace glwpp {
    
#ifdef GLWPP_DEBUG
    static constexpr bool GL_DEBUG = true;
#else
    static constexpr bool GL_DEBUG = false;
#endif

namespace detailed {
    const GLenum FUNC_NAME = 0;

    const std::unordered_map<const void*, const std::unordered_map<GLenum, const std::string>> ERR_DESCRIPTOR {
        {(void *)&glNamedBufferSubData, {
            {FUNC_NAME, "glNamedBufferSubData"},
            {GL_INVALID_ENUM, "target is not one of the accepted buffer targets."},
            {GL_INVALID_VALUE, "offset or size is negative"
                               "\nor if $offset + size$ is greater than the value of GL_BUFFER_SIZE for the specified buffer object"},
            {GL_INVALID_OPERATION, "zero is bound to target."
                                   "\nor buffer is not the name of an existing buffer object"
                                   "\nor any part of the specified range of the buffer object is mapped with glMapBufferRange or glMapBuffer, unless it was mapped with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRange access flags"
                                   "\nor the value of the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer object is GL_TRUE and the value of GL_BUFFER_STORAGE_FLAGS for the buffer object does not have the GL_DYNAMIC_STORAGE_BIT bit set"}
        }},
        {(void *)&glGetNamedBufferSubData, {
            {FUNC_NAME, "glGetNamedBufferSubData"},
            {GL_INVALID_ENUM, "target is not one of the generic buffer binding targets."},
            {GL_INVALID_VALUE, "offset or size is negative"
                               "\nor if $offset + size$ is greater than the value of GL_BUFFER_SIZE for the buffer object."},
            {GL_INVALID_OPERATION, "zero is bound to target"
                                   "\nor buffer is not the name of an existing buffer object"
                                   "\nthe buffer object is mapped with glMapBufferRange or glMapBuffer, unless it was mapped with the GL_MAP_PERSISTENT_BIT bit set in the glMapBufferRange access flags"},
        }},
        {(void *)glShaderSource, {
            {FUNC_NAME, "glShaderSource"},
            {GL_INVALID_VALUE, "shader is not a value generated by OpenGL"
                               "\nor count is less than 0"},
            {GL_INVALID_OPERATION , "shader is not a value generated by OpenGL"},
        }},
        {(void *)glAttachShader, {
            {FUNC_NAME, "glAttachShader"},
            {GL_INVALID_VALUE, "either program or shader is not a value generated by OpenGL"},
            {GL_INVALID_OPERATION, "program is not a program object"
                                   "\nor shader is not a shader object"
                                   "\nor shader is already attached to program"}
        }}
    };
};

std::string getErrDecription(void *func, GLenum err){
    static std::string empty = "no description";
    auto list = detailed::ERR_DESCRIPTOR.find(func);
    if (list == detailed::ERR_DESCRIPTOR.end()){
        
        return empty;
    }

    auto name = list->second.find(detailed::FUNC_NAME);
    std::string result(name == list->second.end() ? "Noname" : name->second);

    auto desc = list->second.find(err);
    if (desc == list->second.end()){
        return result + ": " + empty;
    }

    return result + ": " + desc->second;
};

void printErr(void *func, std::source_location loc = std::source_location::current()){
    auto err = glGetError();
    if (err == GL_NO_ERROR) return;

    std::cout << getErrDecription(func, err) << std::endl;
    std::cout << loc.file_name() << ":" << loc.line() << std::endl;
};

}